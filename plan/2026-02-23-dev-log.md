# Dev Log — 2026-02-23

## Session 1: Planning & Foundation

### Planning Phase
- User requested a plan for implementing The Good Fight solo TTRPG as a browser-based game tracker — fully static, no backend, all client-side
- Claude read the complete game rules PDF (4-page solo TTRPG — card-driven resistance movement game) and created **plan.md**
  - Vanilla HTML/CSS/JS, no framework, no build step, no backend
  - Defined file structure, game state schema, all 7 screens/views, and 6 implementation phases
  - Documented all game rules clarifications (crackdown cascades, influence die upgrades, leader mechanics, etc.)
- User requested the ability for players to bring their own physical dice and cards
- Claude added the **Input Mode** system (digital vs. physical) to plan.md
  - Two independent toggles: dice and cards
  - Players can use the built-in randomness generators or enter results from their own physical dice/deck
  - Async provider abstraction so game logic doesn't care which mode is active
  - Switchable mid-game from a settings gear icon
- User requested that this project implement a test-driven development approach, and creation of TDD.md doc
- Claude created **test-driven-development.md**
  - Explained unit tests vs. integration tests vs. modal flows for reference
  - Defined 50+ specific tests across 7 test files, mapped phase-by-phase to the main plan
  - Documented what we test and what we don't (and why)
- User requested the ability to simulate and analyze automated playthroughs, from 1 to 1,000
- Claude created **simulation.md** — Monte Carlo simulation layer plan
  - Headless game engine runs with AI player strategies (Cautious, Aggressive, Balanced, Random, Custom)
  - Per-turn snapshots, per-game summaries, batch aggregates
  - Interactive dashboard with 8 chart types (win rates, resource curves, crackdown analysis, drilldowns)
  - CSV/JSON export, strategy comparison mode
- After building the majority of the code, Claude was struggling to get tests to run
  - User was easily able to see passing tests in browser
  - Claude attempting to run curl, and `node --check` commands
  - User intervened and requested that Claude analyze what kind of tooling and environment it needs to execute JavaScript tests, and to present lightest-weight as well as most-popular solution options
- Claude proposed three progression stages: Node shim → happy-dom → headless browser
- User suggested skipping the Node shim and starting directly with happy-dom due to project having 4 million weekly downloads, 2MB dependency size, and being actively maintained - no reason to re-invent the wheel and add more code to maintain
  - User also requests retaining Puppeteer/Playwright options (not puppeteer-core) for the future progression step
- Claude updated all three docs with environment requirements and the progression pathway
  - Playing the game: zero installs, any browser
  - Running tests / simulations: Node.js + happy-dom
  - Future: Puppeteer or Playwright if real browser testing is ever needed

### Implementation Phase (Phase 1 — Foundation)
- Claude set up directory structure (`css/`, `js/`, `tests/`)
- Claude created `package.json` with happy-dom as a dev dependency
- Claude built the test runner infrastructure
  - `tests/test-runner.js` — minimal assertion library (assert, assertEqual, assertDeepEqual, assertInRange, assertThrows, etc.) with suite grouping and colored DOM output
  - `tests/tests.html` — browser-based test dashboard with dark themed styling
  - `tests/run-node.js` — Node + happy-dom harness for terminal-based test execution (`npm test`)
- Claude implemented and tested three core modules (TDD — tests written first):
  - **`js/state.js`** — game state creation, save/load via localStorage, resource clamping (Influence 0–500, Heat 0–100, Supplies floor 0), delta helpers — 10 tests
  - **`js/dice.js`** — async dice rolling for d4/d6/d8/d10/d12/d20/d100, injectable provider for physical mode and testing — 11 tests
  - **`js/deck.js`** — 52-card deck creation, Fisher-Yates shuffle, async draw with provider support, card return, value mapping (J=11, Q=12, K=13, A=15) — 15 tests
- **Final result: 36 tests, 36 passing, 0 failing**

## Session 2: Repo Setup & Phase 1 Completion

### Repo Setup
- User updated PDF with rules clarifications: "roll under" requirement, multi-bullet failure handling
- Claude updated plan.md Rules Clarifications section with new rules
- Initialized git repo, created `.gitignore` (node_modules/, .DS_Store) and `README.md`
- Moved all .md files from project root to `/plan/` folder
- User created initial commit and pushed to GitHub (`good-fight-ttrpg`)
- Created `LICENSE` — All Rights Reserved, copyright Andrew Antles

### Implementation Phase (Phase 1 items 5–7)
- Claude implemented and tested three new modules (TDD — tests written first):
  - **`js/ui.js`** — manual input UI components for physical mode: `diceInput(dieType)` shows modal with number input and min/max validation, `cardInput(count)` shows modal with suit + rank dropdowns, handles multi-card draws sequentially. Both return Promises and are compatible as Dice/Deck providers. — 14 tests
  - **`js/app.js`** — screen router (`showScreen`, `currentScreen`), d6 setup tables for Resistance Values and Regime Type from the rulebook (roll or multi-select checkboxes), `rollForSetup()` and `getSetupSelections()` API, `init()` wires up navigation and roll buttons — 13 tests
  - **`index.html`** — app shell with 4 screens: title (New Game / Continue), setup (d6 tables with checkboxes + roll buttons, input mode toggles), game (resource top bar, 3-column dashboard with personnel/operations/log panels, turn controls), victory
  - **`css/style.css`** — dark theme (#1a1a2e bg, gold #c9a84c accents), screen show/hide via `.active` class, game dashboard CSS Grid layout, modal overlay styling, setup table styling
- **Phase 1 complete. Final result: 63 tests, 63 passing, 0 failing**
