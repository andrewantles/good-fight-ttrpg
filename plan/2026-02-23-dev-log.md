# Dev Log — 2026-02-23

## Session 1: Planning & Foundation

### Planning Phase
- User requested a plan for implementing The Good Fight solo TTRPG as a browser-based game tracker — fully static, no backend, all client-side
- Claude read the complete game rules PDF (4-page solo TTRPG — card-driven resistance movement game) and created **plan.md**
  - Vanilla HTML/CSS/JS, no framework, no build step, no backend
  - Defined file structure, game state schema, all 7 screens/views, and 6 implementation phases
  - Documented all game rules clarifications (crackdown cascades, influence die upgrades, leader mechanics, etc.)
- User requested the ability for players to bring their own physical dice and cards
- Claude added the **Input Mode** system (digital vs. physical) to plan.md
  - Two independent toggles: dice and cards
  - Players can use the built-in randomness generators or enter results from their own physical dice/deck
  - Async provider abstraction so game logic doesn't care which mode is active
  - Switchable mid-game from a settings gear icon
- User requested that this project implement a test-driven development approach, and creation of TDD.md doc
- Claude created **test-driven-development.md**
  - Explained unit tests vs. integration tests vs. modal flows for reference
  - Defined 50+ specific tests across 7 test files, mapped phase-by-phase to the main plan
  - Documented what we test and what we don't (and why)
- User requested the ability to simulate and analyze automated playthroughs, from 1 to 1,000
- Claude created **simulation.md** — Monte Carlo simulation layer plan
  - Headless game engine runs with AI player strategies (Cautious, Aggressive, Balanced, Random, Custom)
  - Per-turn snapshots, per-game summaries, batch aggregates
  - Interactive dashboard with 8 chart types (win rates, resource curves, crackdown analysis, drilldowns)
  - CSV/JSON export, strategy comparison mode
- After building the majority of the code, Claude was struggling to get tests to run
  - User was easily able to see passing tests in browser
  - Claude attempting to run curl, and `node --check` commands
  - User intervened and requested that Claude analyze what kind of tooling and environment it needs to execute JavaScript tests, and to present lightest-weight as well as most-popular solution options
- Claude proposed three progression stages: Node shim → happy-dom → headless browser
- User suggested skipping the Node shim and starting directly with happy-dom due to project having 4 million weekly downloads, 2MB dependency size, and being actively maintained - no reason to re-invent the wheel and add more code to maintain
  - User also requests retaining Puppeteer/Playwright options (not puppeteer-core) for the future progression step
- Claude updated all three docs with environment requirements and the progression pathway
  - Playing the game: zero installs, any browser
  - Running tests / simulations: Node.js + happy-dom
  - Future: Puppeteer or Playwright if real browser testing is ever needed

### Implementation Phase (Phase 1 — Foundation)
- Claude set up directory structure (`css/`, `js/`, `tests/`)
- Claude created `package.json` with happy-dom as a dev dependency
- Claude built the test runner infrastructure
  - `tests/test-runner.js` — minimal assertion library (assert, assertEqual, assertDeepEqual, assertInRange, assertThrows, etc.) with suite grouping and colored DOM output
  - `tests/tests.html` — browser-based test dashboard with dark themed styling
  - `tests/run-node.js` — Node + happy-dom harness for terminal-based test execution (`npm test`)
- Claude implemented and tested three core modules (TDD — tests written first):
  - **`js/state.js`** — game state creation, save/load via localStorage, resource clamping (Influence 0–500, Heat 0–100, Supplies floor 0), delta helpers — 10 tests
  - **`js/dice.js`** — async dice rolling for d4/d6/d8/d10/d12/d20/d100, injectable provider for physical mode and testing — 11 tests
  - **`js/deck.js`** — 52-card deck creation, Fisher-Yates shuffle, async draw with provider support, card return, value mapping (J=11, Q=12, K=13, A=15) — 15 tests
- **Final result: 36 tests, 36 passing, 0 failing**

## Session 2: Repo Setup & Phase 1 Completion

### Repo Setup
- User updated PDF with rules clarifications: "roll under" requirement, multi-bullet failure handling
- Claude updated plan.md Rules Clarifications section with new rules
- Initialized git repo, created `.gitignore` (node_modules/, .DS_Store) and `README.md`
- Moved all .md files from project root to `/plan/` folder
- User created initial commit and pushed to GitHub (`good-fight-ttrpg`)
- Created `LICENSE` — All Rights Reserved, copyright Andrew Antles

### Implementation Phase (Phase 1 items 5–7)
- Claude implemented and tested three new modules (TDD — tests written first):
  - **`js/ui.js`** — manual input UI components for physical mode: `diceInput(dieType)` shows modal with number input and min/max validation, `cardInput(count)` shows modal with suit + rank dropdowns, handles multi-card draws sequentially. Both return Promises and are compatible as Dice/Deck providers. — 14 tests
  - **`js/app.js`** — screen router (`showScreen`, `currentScreen`), d6 setup tables for Resistance Values and Regime Type from the rulebook (roll or multi-select checkboxes), `rollForSetup()` and `getSetupSelections()` API, `init()` wires up navigation and roll buttons — 13 tests
  - **`index.html`** — app shell with 4 screens: title (New Game / Continue), setup (d6 tables with checkboxes + roll buttons, input mode toggles), game (resource top bar, 3-column dashboard with personnel/operations/log panels, turn controls), victory
  - **`css/style.css`** — dark theme (#1a1a2e bg, gold #c9a84c accents), screen show/hide via `.active` class, game dashboard CSS Grid layout, modal overlay styling, setup table styling
- **Phase 1 complete. Final result: 63 tests, 63 passing, 0 failing**

## Session 3: Phase 2 — Game Setup & Personnel (2026-02-26)

### Phase 2 Implementation

- User instructed to skip plan mode and implement directly, using existing `/plan/` docs as the planning artifact
- Claude implemented Phase 2 items 8–12 in `app.js` and `css/style.css`:

#### `js/app.js` additions

- **`gameState`** — module-level state variable; single source of truth while playing
- **`getState()`** — accessor for current game state
- **`beginGame()`** — captures resistance/regime checkbox selections and input mode toggles, creates + shuffles 52-card recruitment deck, initializes state, syncs providers, saves to localStorage slot `'current'`, transitions to game screen
- **`continueGame()`** — loads `'current'` save slot, syncs providers, transitions to game screen
- **`syncInputProviders()`** — sets `Dice` and `Deck` providers to `UI.diceInput` / `UI.cardInput` (physical) or `null` (digital) based on `state.inputMode`
- **`renderResources()`** — updates top-bar resource values; heat value gets color class (`heat-low/med/high/critical`) based on thresholds (25/50/75)
- **`renderGameState()`** — calls `renderResources()` + `renderPersonnel()`
- **`renderPersonnel()`** — renders all four personnel sections using `renderCardList()`
- **`renderCardList(sectionId, cards, options)`** — populates a section's `.card-list`; supports timer badges and Recruit buttons; wires click handlers for recruit buttons
- **`renderCard(card)`** — returns HTML string: suit icon (♠♥♦♣) + rank + numeric value, with `.suit-red` / `.suit-dark` color classes
- **`getInfluenceDie(influence)`** — returns bonus die type (d4/d6/d8/d10/d12/d20) for influence upgrade tiers (50/100/150/200/250/300+), or null
- **`attemptRecruit(poolIndex)`** — recruit attempt from pool; **has known rule bugs (see questions.md)** — currently being revised
- **`drawToPool(count)`** — draws N cards from recruitment deck into recruit pool; logs each draw; saves state; re-renders
- **`updateLeaderSkill()`** — sets `leaderSkillLevel` to max operative card value; **has known issue (see questions.md)**
- **`addLogEntry(text)`** — appends `{ turn, text }` to `turnLog`; calls `renderLog()`
- **`renderLog()`** — renders turn log panel with turn number badges; auto-scrolls to bottom
- **`suitSymbol(suit)`** — internal helper, returns Unicode suit character
- **`init()`** — updated to enable/disable Continue button based on `'current'` save, wire Begin button to `beginGame()`

#### `css/style.css` additions

- **Card component** — `.card`, `.suit-red`, `.suit-dark`, `.card-suit`, `.card-rank`, `.card-value`
- **Card row** — `.card-row` flex container with bg, border, border-radius
- **Badge** — `.badge` for initiate/detained timer display (yellow pill)
- **Recruit button** — `.btn-recruit` aligned to right of card row
- **Empty state** — `.empty-list` muted italic text when section is empty
- **Heat color coding** — `.heat-low` (green), `.heat-med` (yellow), `.heat-high` (orange), `.heat-critical` (red)
- **Turn log** — `.log-entry`, `.log-turn` (gold turn number)

### Known Issues Flagged (see questions.md)

- `attemptRecruit` has multiple rule interpretation bugs: leader block check is wrong (leader should always be able to recruit), dice roll logic is wrong (roll is the check, not added to operative value), supplies-for-upgrade not implemented
- `updateLeaderSkill` sets to 0 when no operatives — but leader should always be able to attempt recruitment independent of this value
- `drawToPool` is currently orphaned (no button/trigger yet); will be wired in Phase 3 as part of the Recruit operation
- No Phase 2 tests written yet — tests blocked until `attemptRecruit` rule bugs are fixed

### Test Status
- **63 tests, 63 passing, 0 failing** (unchanged — Phase 2 tests not yet written)
